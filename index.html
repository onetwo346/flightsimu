<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced 3D Shooting Sim</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        .joystick {
            position: absolute; width: 100px; height: 100px; border-radius: 50%;
            background: rgba(255, 255, 255, 0.3); border: 2px solid white;
            touch-action: none; /* Prevents default touch behavior */
        }
        #moveJoystick { bottom: 20px; left: 20px; }
        #lookJoystick { bottom: 20px; right: 20px; }
        .knob {
            width: 40px; height: 40px; border-radius: 50%; background: white;
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
        }
    </style>
</head>
<body>
    <div id="moveJoystick" class="joystick"><div class="knob"></div></div>
    <div id="lookJoystick" class="joystick"><div class="knob"></div></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(10, 20, 10);
        scene.add(directionalLight);

        // Floor (bigger and textured-like)
        const floorGeometry = new THREE.PlaneGeometry(200, 200);
        const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x228B22, shininess: 10 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        scene.add(floor);

        // Walls
        const wallGeometry = new THREE.BoxGeometry(200, 10, 1);
        const wallMaterial = new THREE.MeshPhongMaterial({ color: 0x696969 });
        const wall1 = new THREE.Mesh(wallGeometry, wallMaterial);
        wall1.position.set(0, 5, -100);
        scene.add(wall1);
        const wall2 = new THREE.Mesh(wallGeometry, wallMaterial);
        wall2.position.set(0, 5, 100);
        scene.add(wall2);
        const wall3 = new THREE.Mesh(wallGeometry, wallMaterial);
        wall3.rotation.y = Math.PI / 2;
        wall3.position.set(-100, 5, 0);
        scene.add(wall3);
        const wall4 = new THREE.Mesh(wallGeometry, wallMaterial);
        wall4.rotation.y = Math.PI / 2;
        wall4.position.set(100, 5, 0);
        scene.add(wall4);

        // Skybox
        const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
        const skyMaterial = new THREE.MeshBasicMaterial({ color: 0x87CEEB, side: THREE.BackSide });
        const sky = new THREE.Mesh(skyGeometry, skyMaterial);
        scene.add(sky);

        // Targets (better design)
        const targetGeometry = new THREE.SphereGeometry(1, 16, 16);
        const targetMaterial = new THREE.MeshPhongMaterial({ color: 0xff4500, shininess: 50 });
        const targets = [];
        for (let i = 0; i < 10; i++) {
            const target = new THREE.Mesh(targetGeometry, targetMaterial);
            target.position.set(Math.random() * 180 - 90, 1, Math.random() * 180 - 90);
            scene.add(target);
            targets.push(target);
        }

        // Player setup
        camera.position.y = 2;
        const velocity = new THREE.Vector3();
        const moveSpeed = 0.2;

        // Touch controls
        const moveJoystick = document.getElementById('moveJoystick');
        const moveKnob = moveJoystick.querySelector('.knob');
        const lookJoystick = document.getElementById('lookJoystick');
        const lookKnob = lookJoystick.querySelector('.knob');
        let moveTouchId = null, lookTouchId = null;
        let moveVector = new THREE.Vector2(), lookVector = new THREE.Vector2();

        function updateJoystick(touch, joystick, knob, vector) {
            const rect = joystick.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const dx = Math.min(Math.max(touch.clientX - centerX, -50), 50);
            const dy = Math.min(Math.max(touch.clientY - centerY, -50), 50);
            knob.style.left = `calc(50% + ${dx}px)`;
            knob.style.top = `calc(50% + ${dy}px)`;
            vector.set(dx / 50, -dy / 50); // Normalized -1 to 1
        }

        document.addEventListener('touchstart', (e) => {
            for (let touch of e.changedTouches) {
                if (!moveTouchId && moveJoystick.contains(touch.target)) {
                    moveTouchId = touch.identifier;
                    updateJoystick(touch, moveJoystick, moveKnob, moveVector);
                } else if (!lookTouchId && lookJoystick.contains(touch.target)) {
                    lookTouchId = touch.identifier;
                    updateJoystick(touch, lookJoystick, lookKnob, lookVector);
                }
            }
        });

        document.addEventListener('touchmove', (e) => {
            for (let touch of e.touches) {
                if (touch.identifier === moveTouchId) {
                    updateJoystick(touch, moveJoystick, moveKnob, moveVector);
                } else if (touch.identifier === lookTouchId) {
                    updateJoystick(touch, lookJoystick, lookKnob, lookVector);
                }
            }
        });

        document.addEventListener('touchend', (e) => {
            for (let touch of e.changedTouches) {
                if (touch.identifier === moveTouchId) {
                    moveTouchId = null;
                    moveKnob.style.left = '50%';
                    moveKnob.style.top = '50%';
                    moveVector.set(0, 0);
                } else if (touch.identifier === lookTouchId) {
                    lookTouchId = null;
                    lookKnob.style.left = '50%';
                    lookKnob.style.top = '50%';
                    lookVector.set(0, 0);
                }
            }
        });

        // Shooting (tap screen outside joysticks)
        document.addEventListener('touchstart', (e) => {
            if (!moveJoystick.contains(e.target) && !lookJoystick.contains(e.target)) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects(targets);
                if (intersects.length > 0) {
                    scene.remove(intersects[0].object);
                    targets.splice(targets.indexOf(intersects[0].object), 1);
                }
            }
        });

        // Keyboard fallback
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        document.addEventListener('keydown', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = true; break;
                case 'KeyS': moveBackward = true; break;
                case 'KeyA': moveLeft = true; break;
                case 'KeyD': moveRight = true; break;
            }
        });
        document.addEventListener('keyup', (e) => {
            switch (e.code) {
                case 'KeyW': moveForward = false; break;
                case 'KeyS': moveBackward = false; break;
                case 'KeyA': moveLeft = false; break;
                case 'KeyD': moveRight = false; break;
            }
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Movement (touch or keyboard)
            velocity.x *= 0.9; // Friction
            velocity.z *= 0.9;

            const moveX = moveVector.x || (moveRight ? 1 : moveLeft ? -1 : 0);
            const moveZ = moveVector.y || (moveForward ? 1 : moveBackward ? -1 : 0);
            velocity.x += moveX * moveSpeed;
            velocity.z += moveZ * moveSpeed;

            camera.position.x += velocity.x;
            camera.position.z += velocity.z;

            // Look (touch only, mouse handled separately for desktop)
            camera.rotation.y -= lookVector.x * 0.05;
            camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x - lookVector.y * 0.05));

            // Keep player above floor
            camera.position.y = Math.max(2, camera.position.y);

            renderer.render(scene, scene);
        }
        animate();

        // Mouse look for desktop
        let isMouseLocked = false;
        document.addEventListener('click', () => {
            if (!isMouseLocked) {
                renderer.domElement.requestPointerLock();
                isMouseLocked = true;
            }
        });
        document.addEventListener('mousemove', (e) => {
            if (isMouseLocked) {
                camera.rotation.y -= e.movementX * 0.002;
                camera.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, camera.rotation.x - e.movementY * 0.002));
            }
        });
        document.addEventListener('click', () => {
            if (isMouseLocked) {
                const raycaster = new THREE.Raycaster();
                raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
                const intersects = raycaster.intersectObjects(targets);
                if (intersects.length > 0) {
                    scene.remove(intersects[0].object);
                    targets.splice(targets.indexOf(intersects[0].object), 1);
                }
            }
        });

        // Resize handler
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
